\section{Definitions and Notation}
\subsection{Concrete Execution}



We model a hardware module as a tuple $\hardwaredesign = (\concstates,
\concstate_0, \concinputs,\concexecution)$, where
\begin{itemize}
\item $\concstates$ is the finite set of states of the module,
\item $\concstate_0 \in \concstates$ is the initial state of the module,
\item $\concinputs = \{0,1\}^n$ is the finite set of input values---the domain---of the module, and
\item $\concexecution: \concstates \times \concinputs \rightarrow \concstates$ is the transition function of the module.
\end{itemize}

%% : \{(\variable_0,\concvalue), (\variable_1,\concvalue), \ldots, (\variable_n,\concvalue)\}$ is the finite set of state variables and their valuation,
%% : $\{(\inputvariable_0,\concvalue), (\inputvariable_1,\concvalue),$
%%   \ldots, $(\inputvariable_m,\concvalue)\}$ is the set of input parameters and
%%   their valuation.

A state $\concstate \in \concstates$ of the module is a concrete valuation to all
registers in the design: $r_0 = i, r_1 = j, \ldots, r_m = k$, where $r_0, r_1,
r_m$ represent the stateful registers and $i, j, k
\in \{0,1\}^*$. 
The initial state of the module, $\concstate_0$, sometimes called the reset state, is the
valuation taken by the stateful registers of the design after the power-on
cycle.
The domain of the module is the set of binary strings of length $n$, which
represents the concatenation of multiple input parameters to the module.
The transition function takes the module from one state to the next state. It
represents the execution of a single clock-cycle in hardware. The transition function is
left-total: for every $\concstate \in \concstates$ and every $\concinput \in
\concinputs$ \concexecution{} is defined. We do not model the output of the
module explicitly; it is the identity function taken over a subset of the
registers in the design.

\subsection{Symbolic Execution}
The result of symbolic execution is a rooted, binary $\tree = (N, E, l)$, where
$N$ is the set of nodes of the tree, $E$ is the set of directed edges connecting
two nodes, and $l \in N$ is a particular leaf node of interest in the tree. This
leaf node represents a desired next-state of the module being symbolically
explored, and in the recursive strategy, it is this leaf node that is joined to
the root node of a subsequent tree in the search.

Each node $n \in N$ of the tree is a tuple $n = (\symstate, \pathcondition)$, where
\begin{itemize}
\item $\symstate$ is a (partially) symbolic state of the module and
\item $\pathcondition$ is the current path condition.
\end{itemize}

A symbolic state assigns a symbolic expression, \symexpression, to every register in the design: $r_0 =
\symexpression_0, r_1 = \sigma_1, \ldots, r_m = \sigma_m$. A symbolic expression
\symexpression{} contains at least one symbol and may contain zero or more concrete
literals, arithmetic operators, and logical operators. Examples of
symbolic expressions include `$\alpha$' and `$\alpha + 1$,' where
$\alpha$ is a symbol used by the symbolic execution engine.

A path condition, \pathcondition, is a conjunction of propositions involving
symbolic expressions. For example `$\pathcondition = \alpha + 1 \ge 0 \wedge \alpha < 1$' is a
possible path condition.

We define \symexecution() for a particular hardware module as an abstract method
that takes as input an initial symbolic
state $\symstate$, an initial path condition $\pathcondition_0 = \texttrue$, and a
set of symbolic inputs, and 
returns a tree of explored paths. In the recursive strategy, \symexecution{} is
always called with an initial
symbolic state that is fully symbolic: $r_0 = \alpha, r_1 = \beta, \ldots, r_m = \omega$.

The alphabet of symbols that can appear in a path condition is the union of the
alphabet of symbols used to define a symbolic state and the alphabet of symbols
used as input values by \symexecution{}: $\Sigma_{\pathcondition} = \Sigma_{\symstate} \cup \Sigma_i$.


%% We model a symbolic execution engine as a tuple $\symbolicexecutionengine =
%% (\symstates, \rootsymstate, \symalphabet, \pathconditions, \symexecution,  
%% \trees)$, where
%% \begin{itemize}
%% \item $\symstates$ is the set of (partially) symbolic states : $\{(\variable_0,\symvalue), (\variable_1,\symvalue), \ldots, (\variable_n,\symvalue)\}$
%% \item $\rootsymstate \in \symstates$
%% \item $\symexecution: \{\symstates,\pathcondition\}
%%   \times \{\syminputs\} \rightarrow \trees$
%% \item $\pathconditions$
%% \item $\symalphabet$ The alphabet of symbols that appear in symbolic expressions
%%   and symbolic assignments.
%% \item $\trees$ The set of trees $\tree = \{E,\nodes\}$. Each tree is a binary tree of nodes.
%% \end{itemize}


%% \begin{itemize}
%% \item $\pathcondition \in \pathconditions$ is the path condition of a particular node of a tree.
%% \item $\pathconditions \subseteq \mathrm{symexpressions}$ Path condition is a subtype of
%%   symexpressions. The set of all path conditions is a subset of the set of all
%%   symexpressions.
%% \item $\nodes: \{\symstate,\pathcondition\}$, where $\symstate \in \symstates$
%%   and $\pathcondition \in \pathconditions$.
%% \item $\syminputs: <(\inputvariable_0, \symexpression), (\inputvariable_1,
%%   \symexpression), \ldots, (\inputvariable_m, \symexpression)>$
%% \end{itemize}



%% We model the program to be symbolically executed
%% S = {(reg_0, symexpr_0), (reg_1, symexpr_1), ..., (reg_n, symexpr_n)} (edited)
%% symInp = {(inp_0, symexpr_0), (inp_1, symexpr_1), ..., (inp_k, symexpr_k)} (edited)
%% Inp = {(inp_0, inpval_0), (inp_1, inpval_1), ..., (inp_k, inpval_k)} (edited)
%% C = {(reg_0, concval_0), (reg_1, concval_1), ..., (reg_n, concval_n)}

\subsection{Properties of Symbolic Execution}
King formalized the use of symbolic execution~\cite{king1976symbolic} and
described three fundamental
properties provided by a symbolic execution engine. We name and summarize the properties
and for each, give our formal expression of the property.
\setcounter{property}{0}
\renewcommand{\theproperty}{K.\arabic{property}}
\begin{property}[Sound Paths]
  \label{prop:kingsound}
  The path condition $\pathcondition$ never becomes unsatisfiable. For each
  leaf node $l$ of a symbolic execution tree, there exists, for the path condition
  associated with $l$, at
  least one satisfying concrete valuation to the symbols of the path
  condition; that is, one mapping of symbols to concrete values that
  would make the path condition evaluate to \texttrue. If this mapping of satisfying concrete values were
  applied to the initial symbolic state and symbolic inputs, the resulting
  concrete execution would follow the same path through the program as was taken
  by the symbolic execution engine to arrive at the leaf node $l$. In other
  words, all paths taken by the symbolic execution engine correspond to feasible
  paths through the program.
  
  We express this in the following way: 
  
%%   \begin{align*}
%%   \forall a = \mathtt{maptoalph}(\mathrm{alphabet}), & n =
%% \mathtt{intree}(\symexecution(\symstate,\syminput)), \\
%%  & \mathtt{simplify}(\mathtt{plugin}(n.\pathcondition,a) = \texttrue.
%%   \end{align*}

  \begin{align*}
    \forall m = \mathtt{map(\cdot)},~\symstate \in \symstates,~\alpha \in \Sigma_i,~& n \in \tree = \symexecution(\symstate,\pathcondition_0,\alpha), \\
    & \mathtt{simplify}(\mathtt{applymap}(n.\pathcondition,m)) = \texttrue.
  \end{align*}
  Where $\mathtt{map(\cdot)}$ is the set of all functions that map from the set
  of symbols $\Sigma$ to the set of concrete values, \symstates{} is the set of all
  possible symbolic states, $\Sigma_i$ is the set of symbolic input values, and $n$ is a node in the tree $t$ produced by a call
  to \symexecution.
\end{property}


\begin{property}[Unique Paths]
  \label{prop:kingunique}
The path condition $\pathcondition_1$ and $\pathcondition_2$ associated with any two paths of the
tree are mutually unsatisfiable. In other words, there exists no concrete
valuation that could drive execution down two distinct paths of the symbolic
execution tree.

We express this the following way: 

\begin{align*}
\forall m = \mathtt{map(\cdot)},~\symstate \in \symstates,~\alpha \in
\Sigma_i,~& n_1,~ n_2 \in \tree =
\symexecution(\symstate,\pathcondition_0,\alpha), \\
& n_1 \neq n_2 \\
&  \wedge
(\mathtt{ischildof}(n_1, n_2) \vee  \mathtt{ischildof}(n_2, n_1))= \textfalse \\
&\rightarrow \mathtt{simplify}(\mathtt{applymap}(n_1.\pathcondition \wedge n_2.\pathcondition,m)) = \textfalse.
\end{align*}

%% \begin{align*}
%% \forall a = \mathtt{maptoalph}(\mathrm{alphabet}), &  n_1 n_2 =
%% \mathtt{intree}(\symexecution(\symstate,\syminput)) \\
%% & \wedge
%% n_1 \neq n_2 \\
%% &  \wedge
%% (\mathtt{ischildof}(n_1, n_2) \vee  \mathtt{ischildof}(n_2, n_1))= \textfalse \\
%% &\rightarrow \mathtt{simplify}(\mathtt{plugin}(l.\pathcondition,a) = \textfalse
%% \end{align*}
\end{property}

\begin{property}[Commutativity]
  \label{prop:kingcommutativity}
  The actions of symbolically executing a program and instantiating symbols with
  concrete values ($\mathtt{applymap(\cdot)}$ in our model) are commutative. If a
  mapping is first chosen and then the program is executed concretely, the end
  state will be the same as if the program is executed symbolically and then,
  for a particular leaf, a mapping is chosen such that the path constraint of
  that leaf is satisfied.

  %% We define some functions.
  %% \begin{itemize}
  %% \item maptoalph: $\{\symalphabet\} \rightarrow \{\concvalue\}$
  %% \item plugin: $\{\symexpression\} \times \{\concvalue\} \rightarrow
  %%   \{\concexpression\}$
  %% \item simplify: $\{\concexpression\} \rightarrow \{\concvalue\}$
  %% \end{itemize}




\begin{align*}
\forall m = \mathtt{map(\cdot)},~\symstate \in \symstates,~\alpha \in \Sigma_i,~& l \in \tree = \symexecution(\symstate,\pathcondition_0,\alpha) \wedge
\mathtt{simplify}(\mathtt{applymap}(l.\pathcondition,m)) = \texttrue \\
&\rightarrow \mathtt{simplify}(\mathtt{applymap}(l.\symstate,m)) = \\
&\qquad\concexecution(\mathtt{simplify}(\mathtt{applymap}(\symstate,m)),\mathtt{simplify}(\mathtt{applymap}(\syminput,m))).
\end{align*}
Where $l$ is a leaf node of the tree returned by \symexecution.

%% \begin{align*}
%% \forall a = \mathtt{maptoalph}(\mathrm{alphabet}), & l =
%% \mathtt{isleaf}(\symexecution(\symstate,\syminput)) \wedge
%% \mathtt{simplify}(\mathtt{plugin}(l.\pathcondition,a) = \texttrue \\
%% &\rightarrow \mathtt{simplify}(\mathtt{plugin}(l.\symstate,a)) = \\
%% &\qquad\concexecution(\mathtt{simplify}(\mathtt{plugin}(\symstate)),\mathtt{simplify}(\mathtt{plugin}(\syminput)))
%% \end{align*}

\end{property}



