\section{Definitions and Notation}
\subsection{Processor Model}
\label{sec:procmodel}
In the formalization of their search strategy~\cite{fmspaper}, Zhang et
al. model a processor as a tuple $M = (S, s_0, I, \delta, O, \omega)$, where
\begin{itemize}
  \item $S = \{s_0, s_1, \ldots, s_k\}$ is the finite set of states of the
    processor,
  \item $s_0 \in S$ is the initial state of the processor,
  \item $I = \{0,1\}^n$ is the finite set of input strings to the processor,
  \item $\delta: S \times I \rightarrow S$ is the transition function of the processor,
  \item $O = \{0,1\}^m$ is the finite set of output strings of the processor,
    and
  \item $\omega: S \rightarrow O$ is the output function of the processor.
\end{itemize}

A state $s \in S$ is determined by the values of the \emph{stateful} registers
of the design. These include both architectural registers, which are visible to
software, and microarchitectural registers, which are not visible to
software. Examples of the former include general purpose registers, the stack
pointer, the instruction pointer, and some control registers. Examples of the
latter include the buffers between stages of a pipeline, branch prediction
registers, reorder buffers, and many control signals. These are all stateful in that
they hold their current value up to and until getting updated at the next clock
cycle. As such, their current-state value can be an input to the calculation of their
next-state value. 

The initial state $s_0$ represents the starting state of the processor
immediately after a
power-on or reset cycle. Many registers have a value of 0 in this state.

An input string $i \in I$ represents the concatenation of the several input
signals to the processor. The string has a fixed length $n$. The list of input
signals includes the instructions and data fetched from memory (or from a
cache), plus control, error, debug, and interrupt signals.

The transition function $\delta$ defines how state is updated in a single clock
cycle. It is left-total: for every $s \in S$ and every $i \in I$, $\delta$ is defined.

An output string $o \in O$ represents the concatenation of the several output
signals of the processor. The string has a fixed length. The list of output
signals includes addresses and data values to be written to memory, control
signals, and error signals.

The output function $\omega$ determines the value of $o$ in each clock cycle. It
is typically the identity function taken over a subset of the stateful registers
in the design.

\subsection{Symbolic Execution}


The symbolic exploration of a design is modeled by a tuple $\tree = (N,E)$ representing a rooted, binary tree, where
$N$ is the set of nodes of the tree and $E$ is the set of directed edges connecting
two nodes.  model, each node $n \in N$ of the tree represents a conditional branch point in the
design; we elide the non-branching nodes---those that represent
straight-line code and would have only a single child node. The two edges connecting $n$ to its two children nodes represent the two
possible paths of forward execution at that branch point.

Each node is a tuple $n = (\symstate, \pathcondition)$, where
\begin{itemize}
\item $\symstate$ is the symbolic state of the module at the current point of
  execution, and
\item $\pathcondition$ is the path condition associated with the current
  symbolic state.
\end{itemize}


As with standard execution, in symbolic execution, a symbolic state $\symstate$
is determined by the values of the stateful registers of the design. However,
the values may be symbolic, or
concrete literals as in standard execution, or a combination of the two.

The path condition $\pathcondition$ is a Boolean formula over a subset of the input signals and
stateful registers of the design. The path condition of the root node of the
tree is always initialized to true: $n_r = (\symstate, \texttrue)$.

\subsection{Coq Model of a Processor Design}
We build a model of a hardware design that represents the stateful
registers, their values at clock cycle boundaries, and the transition
function. The model is abstract and suitable to the representation of any design
that is synchronous (i.e., clocked) and includes sequential logic (i.e.,
stateful registers).

We model the design as a Coq program with the following types.
\begin{itemize}
\item \textsf{Register} is an abstract type that is used to represent the
  stateful registers in the RTL design.
\item \textsf{InputSignal} is an abstract type that is used to represent the
  input signals in the RTL design.
\item \textsf{Value} is an abstract type that is used to represent the
  literals that can be assigned to \textsf{Register}s or \textsf{InputSignal}s.
\item $\textsf{Assignment} : (r: \textsf{Register},~ v: \textsf{Value})$ is a
  tuple type that represents the assignment of a value $v \in \textsf{Value}$
  to a register $r \in \textsf{Register}$.
\item $\textsf{InputAssignment} : (i: \textsf{InputSignal},~ v:
  \textsf{Value})$ is a tuple type that represents the assignment of a
  value $v \in \textsf{Value}$ to an input signal $i \in \textsf{InputSignal}$.
\end{itemize}

A state of the processor is represented by a list of \textsf{Assignment} elements, $<a_0, a_1, a_2,
\ldots>$, where each element is a tuple as defined by the type. The list is
defined inductively and has unbounded length in the Coq
program. The initial state of the processor is represented by a particular list
of \textsf{Assignment} elements, denoted as $\mathit{init}$. We will use vector notation to
represent a list of a given type (e.g., $\vv{\textsf{Assignments}} \doteq <a_0,
a_1, a_2, \ldots>$).

Execution is modeled by a function, $\concexecution()$, that maps a list of
\textsf{Assignment} elements and
a list of \textsf{InputAssignment} elements to a list of
\textsf{Assignment} elements. In other words, $\concexecution()$ takes a
processor state and a set of inputs and returns a new processor state. As in our abstract model, it is deterministic and left-total:

\begin{itemize}
\item $\concexecution (\vv{\textsf{Assignments}},~
  \vv{\textsf{InputAssignments}}) : \vv{\textsf{Assignments}}$
\end{itemize}
       
We do not model the output signals of the hardware design explicitly as they not needed
for our proof. If needed, they could be modeled as a subset of the \textsf{Register} type.

%% We present the model here as a tuple $\hardwaredesign =
%% (\registers,\inputsignals,\assignments_{\registers},\assignments_{\inputsignals},\init,\delta)$, which is defined as
%% follows.
%% \begin{itemize}
%% \item $\registers = \{r_0,r_1,\ldots,r_n\}$ is the finite set of state-holding
%%   registers in the design.
%% \item $\inputsignals = \{\inputsignal_0, \inputsignal_1, \ldots,
%%   \inputsignal_m\}$ is the finite set of input signals to the design.
%% \item $\assignments_{\registers} \subseteq \{0,1\}^d$
%%   is the finite set of assignments---valuations---to the state-holding registers. An assignment $\assignment \in \assignments_{\registers}$ is a bitvector that is the
%%   concatenation of valuations to all registers in $\registers$.
%% \item $\assignments_{\inputsignals} \subseteq \{0,1\}^e$ is the finite set of
%%   assignments---valuations---to the input signals. An assignment $\assignment
%%   \in \assignments_{\inputsignals}$ is a bitvector that is the concatenation of
%%   valuations to all input signals in $\inputsignals$.
%% \item $\init \in \assignments_{\registers}$ is the valuation to state-holding
%%   registers immediately after the hardware design's initialization sequence
%%   completes. $\init$ represents the initial state of the hardware
%%   design.
%% \item $\delta: \assignments_{\registers} \times
%%   \assignments_{\inputsignals} \rightarrow \assignments_{\registers}$ is the
%%   transition function, which represents execution of the hardware
%%   design. 
%% \end{itemize}

%% The set $\registers$ are the stateful registers of the design. These are exactly
%% the set of registers that make up the state $s \in S$ in the abstract tuple
%% described in Section~\ref{sec:procmodel}.

%% A valuation $\assignment \in \assignments_{\registers}$ represents a concrete
%% state of the design. The length $d$ of the valuation bitvector is fixed for a
%% given design; every state is represented by a bitvector of length $d$. We do not
%% require, however, that all registers $r_i, r_j \in \registers$ have the same bit
%% length. the size of the state space of the design is determined by $d$:
%% $|\hardwaredesign| = 2^d$.

%% The initial state of the design, $\init$, is sometimes called the reset state and is the
%% valuation of the state-holding registers immediately after the power-on
%% cycle completes.

%% The transition function, $\delta$, is left-total: for every
%% $\assignment_{\registers} \in \assignments_{\registers}$ and every
%% $\assignment_{\inputsignals} \in \assignments_{\inputsignals}$, $\delta$ is
%% defined.




\subsection{Coq Model of Symbolic Execution}
To model the symbolic execution of the processor in our Coq program we introduce
types representing symbolic state, symbolic
execution, and path constraints. The first three types are used in our
representation of symbolic state. 
\begin{itemize}
  \item \textsf{SymbolicExpression} is an abstract type that is used to
    represent the symbolic expression that can be assigned to \textsf{Register}s
    or \textsf{InputSignal}s.
  \item $\textsf{SymbolicAssignment} : (r: \textsf{Register},~
    \symexpression: \textsf{SymbolicExpression})$ is a tuple type that
    represents the assignment of an expression $\symexpression \in
    \textsf{SymbolicExpression}$ to a register $r \in \textsf{Register}$.
  \item $\textsf{SymbolicInputAssignment} : (i: \textsf{InputSignal},~
    \symexpression: \textsf{SymbolicExpression})$ is a tuple type that
    represents the assignment of a symbolic expression $\symexpression \in
    \textsf{SymbolicExpression}$ to an input signal $i \in \textsf{InputSignal}$.
\end{itemize}

A symbolic state of the processor is represented by a list of
\textsf{SymbolicAssignment} elements, $\vv{\textsf{SymbolicAssignments}}$. 



Symbolic execution is modeled by a function, $\symexecution()$, that maps a list
of \textsf{SymbolicAssignment} elements and a list of
\textsf{SymbolicInputAssignment} elements to a binary tree. In other words, it
takes a symbolic state and a set of symbolic inputs and returns a tree that
represents the complete symbolic exploration of the design starting from the given symbolic state. The function is defined as
follows. (We define the \textsf{SymExecTree} type in the following paragraph.)

\begin{itemize}
\item $\symexecution (\vv{\textsf{SymbolicAssignments}},~ 
  \vv{\textsf{SymbolicInputAssignments}}) : \textsf{SymExecTree}$
\end{itemize}

The tree returned by $\symexecution()$ is a binary tree of nodes, where each
node contains a symbolic state and a path condition. We introduce the following
types in our Coq program.

\begin{itemize}
\item \textsf{PathCondition} is an abstract type that represents a
  propositional formula over the symbols used in symbolic expressions.
\item $\textsf{Node} : (\vv{\sigma} : \vv{\textsf{SymbolicAssignment}},~ \pi :
  \textsf{PathCondition})$ is a tuple type that represents a node in the
  binary tree, containing a symbolic state (the list of
  \textsf{SymbolicAssignment} elements) and a path condition.
\end{itemize}

A $\textsf{SymExecTree}$ is defined inductively as a binary tree of \textsf{Node}s.



%% We model a symbolic execution engine as a tuple $\symbolicexecutionengine =
%% (\symstates, \rootsymstate, \symalphabet, \pathconditions, \symexecution,  
%% \trees)$, where
%% \begin{itemize}
%% \item $\symstates$ is the set of (partially) symbolic states : $\{(\variable_0,\symvalue), (\variable_1,\symvalue), \ldots, (\variable_n,\symvalue)\}$
%% \item $\rootsymstate \in \symstates$
%% \item $\symexecution: \{\symstates,\pathcondition\}
%%   \times \{\syminputs\} \rightarrow \trees$
%% \item $\pathconditions$
%% \item $\symalphabet$ The alphabet of symbols that appear in symbolic expressions
%%   and symbolic assignments.
%% \item $\trees$ The set of trees $\tree = \{E,\nodes\}$. Each tree is a binary tree of nodes.
%% \end{itemize}


%% \begin{itemize}
%% \item $\pathcondition \in \pathconditions$ is the path condition of a particular node of a tree.
%% \item $\pathconditions \subseteq \mathrm{symexpressions}$ Path condition is a subtype of
%%   symexpressions. The set of all path conditions is a subset of the set of all
%%   symexpressions.
%% \item $\nodes: \{\symstate,\pathcondition\}$, where $\symstate \in \symstates$
%%   and $\pathcondition \in \pathconditions$.
%% \item $\syminputs: <(\inputvariable_0, \symexpression), (\inputvariable_1,
%%   \symexpression), \ldots, (\inputvariable_m, \symexpression)>$
%% \end{itemize}



%% We model the program to be symbolically executed
%% S = {(reg_0, symexpr_0), (reg_1, symexpr_1), ..., (reg_n, symexpr_n)} (edited)
%% symInp = {(inp_0, symexpr_0), (inp_1, symexpr_1), ..., (inp_k, symexpr_k)} (edited)
%% Inp = {(inp_0, inpval_0), (inp_1, inpval_1), ..., (inp_k, inpval_k)} (edited)
%% C = {(reg_0, concval_0), (reg_1, concval_1), ..., (reg_n, concval_n)}

\subsection{Relating Symbolic to Concrete Execution}
\cks{Use this section to introduce and define the notions of mapping.}

\subsection{Properties of Symbolic Execution}
King formalized the use of symbolic execution~\cite{king1976symbolic} and
described three fundamental
properties provided by a symbolic execution engine. We name and summarize the properties
and for each, give our formal expression of the property.
\setcounter{property}{0}
\renewcommand{\theproperty}{K.\arabic{property}}
\begin{property}[Sound Paths]
  \label{prop:kingsound}
  The path condition $\pathcondition$ never becomes unsatisfiable. For each
  leaf node $l$ of a symbolic execution tree, there exists, for the path condition
  associated with $l$, at
  least one satisfying concrete valuation to the symbols of the path
  condition; that is, one mapping of symbols to concrete values that
  would make the path condition evaluate to \texttrue. If this mapping of satisfying concrete values were
  applied to the initial symbolic state and symbolic inputs, the resulting
  concrete execution would follow the same path through the program as was taken
  by the symbolic execution engine to arrive at the leaf node $l$. In other
  words, all paths taken by the symbolic execution engine correspond to feasible
  paths through the program.
  
  We express this in the following way: 
  
%%   \begin{align*}
%%   \forall a = \mathtt{maptoalph}(\mathrm{alphabet}), & n =
%% \mathtt{intree}(\symexecution(\symstate,\syminput)), \\
%%  & \mathtt{simplify}(\mathtt{plugin}(n.\pathcondition,a) = \texttrue.
%%   \end{align*}

  \begin{align*}
    \forall m = \mathtt{map(\cdot)},~\symstate \in \symstates,~\alpha \in \Sigma_i,~& n \in \tree = \symexecution(\symstate,\pathcondition_0,\alpha), \\
    & \mathtt{simplify}(\mathtt{applymap}(n.\pathcondition,m)) = \texttrue.
  \end{align*}
  Where $\mathtt{map(\cdot)}$ is the set of all functions that map from the set
  of symbols $\Sigma$ to the set of concrete values, \symstates{} is the set of all
  possible symbolic states, $\Sigma_i$ is the set of symbolic input values, and $n$ is a node in the tree $t$ produced by a call
  to \symexecution.
\end{property}


\begin{property}[Unique Paths]
  \label{prop:kingunique}
The path condition $\pathcondition_1$ and $\pathcondition_2$ associated with any two paths of the
tree are mutually unsatisfiable. In other words, there exists no concrete
valuation that could drive execution down two distinct paths of the symbolic
execution tree.

We express this the following way: 

\begin{align*}
\forall m = \mathtt{map(\cdot)},~\symstate \in \symstates,~\alpha \in
\Sigma_i,~& n_1,~ n_2 \in \tree =
\symexecution(\symstate,\pathcondition_0,\alpha), \\
& n_1 \neq n_2 \\
&  \wedge
(\mathtt{ischildof}(n_1, n_2) \vee  \mathtt{ischildof}(n_2, n_1))= \textfalse \\
&\rightarrow \mathtt{simplify}(\mathtt{applymap}(n_1.\pathcondition \wedge n_2.\pathcondition,m)) = \textfalse.
\end{align*}

%% \begin{align*}
%% \forall a = \mathtt{maptoalph}(\mathrm{alphabet}), &  n_1 n_2 =
%% \mathtt{intree}(\symexecution(\symstate,\syminput)) \\
%% & \wedge
%% n_1 \neq n_2 \\
%% &  \wedge
%% (\mathtt{ischildof}(n_1, n_2) \vee  \mathtt{ischildof}(n_2, n_1))= \textfalse \\
%% &\rightarrow \mathtt{simplify}(\mathtt{plugin}(l.\pathcondition,a) = \textfalse
%% \end{align*}
\end{property}

\begin{property}[Commutativity]
  \label{prop:kingcommutativity}
  The actions of symbolically executing a program and instantiating symbols with
  concrete values ($\mathtt{applymap(\cdot)}$ in our model) are commutative. If a
  mapping is first chosen and then the program is executed concretely, the end
  state will be the same as if the program is executed symbolically and then,
  for a particular leaf, a mapping is chosen such that the path constraint of
  that leaf is satisfied.

  %% We define some functions.
  %% \begin{itemize}
  %% \item maptoalph: $\{\symalphabet\} \rightarrow \{\concvalue\}$
  %% \item plugin: $\{\symexpression\} \times \{\concvalue\} \rightarrow
  %%   \{\concexpression\}$
  %% \item simplify: $\{\concexpression\} \rightarrow \{\concvalue\}$
  %% \end{itemize}




\begin{align*}
\forall m = \mathtt{map(\cdot)},~\symstate \in \symstates,~\alpha \in \Sigma_i,~& l \in \tree = \symexecution(\symstate,\pathcondition_0,\alpha) \wedge
\mathtt{simplify}(\mathtt{applymap}(l.\pathcondition,m)) = \texttrue \\
&\rightarrow \mathtt{simplify}(\mathtt{applymap}(l.\symstate,m)) = \\
&\qquad\concexecution(\mathtt{simplify}(\mathtt{applymap}(\symstate,m)),\mathtt{simplify}(\mathtt{applymap}(\syminput,m))).
\end{align*}
Where $l$ is a leaf node of the tree returned by \symexecution.

%% \begin{align*}
%% \forall a = \mathtt{maptoalph}(\mathrm{alphabet}), & l =
%% \mathtt{isleaf}(\symexecution(\symstate,\syminput)) \wedge
%% \mathtt{simplify}(\mathtt{plugin}(l.\pathcondition,a) = \texttrue \\
%% &\rightarrow \mathtt{simplify}(\mathtt{plugin}(l.\symstate,a)) = \\
%% &\qquad\concexecution(\mathtt{simplify}(\mathtt{plugin}(\symstate)),\mathtt{simplify}(\mathtt{plugin}(\syminput)))
%% \end{align*}

\end{property}



\subsection{Recursive Strategy Requirements}
We express the three original requirements of the recursive strategy as
laid out by Zhang et al.~\cite{zhang2018recursive}. 
%The following requirements, when placed on our system, should be enough to prove that the strategy works as expected:
We start by formally defining two instantiation operations that are only informally described
by Zhang et al. but that are used by the strategy requirements.

\subsubsection{Instantiation Operations} 

The root node of a symbolic execution tree $t$ contains a symbolic state
  ($\mathtt{getroot}(t).\symstate$), which can be viewed as a representation of
  a set of possible concrete states. If \symstate{} is fully symbolic, meaning
  that all registers in the design are assigned symbolic expressions ($r_0 =
  \sigma_0, r_1 = \sigma_1, \ldots$), then it represents the set of all
  possible concrete states $\concstates$. From the set of all possible concrete
  states, all possible next states are reachable, and these are represented by
  the leaves of the symbolic execution tree. The symbolic state of each leaf node of the tree
  represents a subset of $\concstates$.

  The effect of the
operations ($\mathtt{concretize\_root}$ and $\mathtt{concretize\_leaf}$) is to take a node (root or leaf) of a symbolic execution tree and
find the set of concrete states represented by the symbolic state of that
node. 
%% Our two instantiation operations are defined in the following way: 
%% $$\mathtt{concretize\_root} : \{ \tree \} \rightarrow \{\concstates\}$$

%% $$\mathtt{concretize\_leaf} : \{ \tree \} \rightarrow \{\concstates\}$$

%% They are bound by the following requirements:

\begin{mydefinition}[\emph{concretize\_root}]
  \label{def:concroot}
  
  For any given leaf node of the
  tree, the set of concrete states represented by that node is reachable, with a
  given input, from a subset of the concrete states represented by the root
  node. This instantiation operation finds that subset of concrete states
  for the particular leaf node of interest of a tree. The operation takes as
  input a tree (remember that a tree is
  the tuple $t = (N, E, l)$, where $l$ is a particular leaf node of interest of
  the tree) and returns
  a set of concrete states. We define it formally here.

  \begin{align*}
\forall \tree \in \trees,~ \concstate \in \concstates,~& \concstate \in
\mathtt{concretize\_root}(t) \leftrightarrow \\
&\exists r,n \in t,~ m = \mathtt{map(\cdot)} \mathrm{~such~that}\\
&r = \mathtt{getroot}(t), n = t.l,
\mathtt{simplify}(\mathtt{applymap} (n.\pathcondition, m)) = \texttrue \\
&\mathrm{and~}  c = \mathtt{simplify}(\mathtt{applymap}(r.\symstate, m)),
    \end{align*}
\end{mydefinition}
where \trees{} is the set of all possible symbolic execution trees.

The definition says that any mapping ($\mathtt{map(\cdot)}$) from symbolic to concrete values that makes
the path condition of the leaf node evaluate to \texttrue{} will, when applied to
the symbolic state of the root node, produce a concrete state in the set returned
by $\mathtt{concretize\_root}$.

\begin{mydefinition}[\emph{concretize\_leaf}]
  \label{def:concleaf}

  This instantiation operation finds the set of concrete states represented by
  the particular leaf node of interest of a tree.
  \begin{align*}
\forall \tree \in \trees,~ \concstate \in \concstates,~& \concstate \in
\mathtt{concretize\_leaf}(t) \leftrightarrow \\
&\exists n \in t,~ m = \mathtt{map(\cdot)} \mathrm{~such~that}\\
&n = t.l,
\mathtt{simplify}(\mathtt{applymap} (n.\pathcondition, m)) = \texttrue \\
&\mathrm{and~}  c = \mathtt{simplify}(\mathtt{applymap}(n.\symstate, m)),
    \end{align*}
\end{mydefinition}
where \trees{} is the set of all possible symbolic execution trees.

The definition says that any mapping ($\mathtt{map(\cdot)}$) from symbolic to concrete values that makes
the path condition of the leaf node evaluate to \texttrue{} will, when applied to
the symbolic state of that same leaf node, produce a concrete state in the set returned
by $\mathtt{concretize\_leaf}$.

\subsubsection{Three Original Requirements} The goal of the symbolic execution
of a hardware design is to find a sequence of $n$ inputs that will take the hardware
module from an initial reset state to an error state in $n$ clock cycles. The
gist of the recursive search strategy is to search backward from the error
state as follows. First use symbolic execution to find a state $s_i$ that has the error
state as one of its possible next-state transitions. Then use symbolic execution
to find a state $s_{i-1}$ that has $s_i$ has one of its possible next-state
transitions. This search continues until one of the found $s_i$'s is a reset
state. Each application of symbolic execution produces a tree with a particular
leaf node of interest---the desired next-state $s_i$. This sequence of trees ($\mathit{tree\_list}$)
must satisfy these three requirements as laid out by Zhang et al.
\setcounter{property}{0}
\renewcommand{\theproperty}{Z.\arabic{property}}
\begin{property}[Start in initial state]
  \label{prop:startinit} The leaf node of interest in the first tree in the
  sequence must be reachable from the initial, reset state.
  \begin{align*}
    \concstate_0 \in \mathtt{concretize\_root}(\mathit{tree\_list}[0]).
  \end{align*}
\end{property}

\begin{property}[End in error state]
  \label{prop:enderror} The leaf node of interest in the last tree in the
  sequence must include, in the set of concrete states it represents, one of the
  desired error states. 
  \begin{align*}
    \mathtt{concretize\_leaf}(\mathit{tree\_list}[n]) \cap \mathit{ER} \neq
    \emptyset,
  \end{align*}
\end{property}
where $\mathit{ER}$ represents the set of desired error states.

\begin{property}[Stitch trees together]
  \label{prop:stitch}
  Consecutive trees in the sequence must form a continuous path of
  execution. That is, the leaf node of one tree must represent a subset of the
  states represented by the root node of the subsequent tree in the sequence.
  \begin{align*}
    &\forall i, 0 \le i < n,\\
    &\quad\mathtt{concretize\_leaf}(\mathit{tree\_list}[i]) \subseteq
\mathtt{concretize\_root}\mathit{tree\_list}[i+1].
\end{align*}

\end{property}

\subsubsection{Modified Requirement}
We find the above properties are not sufficient to prove correctness of the
recursive strategy. We strengthen Property~\ref{prop:enderror} by replacing it with the following.

\setcounter{property}{1}
\renewcommand{\theproperty}{Z.\arabic{property}'} 
\begin{property}[Property~\ref{prop:enderror} correction]
  The leaf node of interest in the last tree in the
  sequence must represent a subset of the desired error states. The leaf node
  can not represent any concrete state that is not an error state.
  \label{prop:correctedz2}
  \begin{align*}
    \mathtt{concretize\_leaf}(\mathit{tree\_list}[n]) \subseteq \mathit{ER}.
  \end{align*}

 \end{property}
