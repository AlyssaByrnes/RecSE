\section{Definitions and Notation}
\subsection{Concrete Execution}



We model a hardware module as a tuple $\hardwaredesign = (\concstates,
\concstate_0, \concinputs,\concexecution)$, where
\begin{itemize}
\item $\concstates$ is the finite set of states of the module,
\item $\concstate_0 \in \concstates$ is the initial state of the module,
\item $\concinputs = \{0,1\}^n$ is the finite set of input values---the domain---of the module, and
\item $\concexecution: \concstates \times \concinputs \rightarrow \concstates$ is the transition function of the module.
\end{itemize}

%% : \{(\variable_0,\concvalue), (\variable_1,\concvalue), \ldots, (\variable_n,\concvalue)\}$ is the finite set of state variables and their valuation,
%% : $\{(\inputvariable_0,\concvalue), (\inputvariable_1,\concvalue),$
%%   \ldots, $(\inputvariable_m,\concvalue)\}$ is the set of input parameters and
%%   their valuation.

A state $\concstate \in \concstates$ of the module is a concrete valuation to all
registers in the design: $r_0 = i, r_1 = j, \ldots, r_m = k$, where $r_0, r_1,
r_m$ represent the stateful registers and $i, j, k
\in \{0,1\}^*$. 
The initial state of the module, $\concstate_0$, sometimes called the reset state, is the
valuation taken by the stateful registers of the design after the power-on
cycle.
The domain of the module is the set of binary strings of length $n$, which
represents the concatenation of multiple input parameters to the module.
The transition function takes the module from one state to the next state. It
represents the execution of a single clock-cycle in hardware. The transition function is
left-total: for every $\concstate \in \concstates$ and every $\concinput \in
\concinputs$ \concexecution{} is defined. We do not model the output of the
module explicitly; it is the identity function taken over a subset of the
registers in the design.

\subsection{Symbolic Execution}
The result of symbolic execution is a rooted, binary $\tree = (N, E, l)$, where
$N$ is the set of nodes of the tree, $E$ is the set of directed edges connecting
two nodes, and $l \in N$ is a particular leaf node of interest in the tree. This
leaf node represents a desired next-state of the module being symbolically
explored, and in the recursive strategy, it is this leaf node that is joined to
the root node of a subsequent tree in the search.

Each node $n \in N$ of the tree is a tuple $n = (\symstate, \pathcondition)$, where
\begin{itemize}
\item $\symstate$ is a (partially) symbolic state of the module and
\item $\pathcondition$ is the current path condition.
\end{itemize}

A symbolic state assigns a symbolic expression, \symexpression, to every register in the design: $r_0 =
\symexpression_0, r_1 = \sigma_1, \ldots, r_m = \sigma_m$. A symbolic expression
\symexpression{} contains at least one symbol and may contain zero or more concrete
literals, arithmetic operators, and logical operators. Examples of
symbolic expressions include `$\alpha$' and `$\alpha + 1 \le \beta$,' where
$\alpha$ and 
$\beta$ are symbols used by the symbolic execution engine.

We define \symexecution() for a particular hardware module as an abstract method
that takes as input an initial symbolic
state $\symstate$, an initial path condition $\pathcondition = \texttrue$, a
set of symbolic input values $\Sigma$, and 
returns a tree of explored paths. In the recursive strategy, \symexecution{} is
always called with an initial
symbolic state that is fully symbolic: $r_0 = \alpha, r_1 = \beta, \ldots, r_m = \omega$.


%% We model a symbolic execution engine as a tuple $\symbolicexecutionengine =
%% (\symstates, \rootsymstate, \symalphabet, \pathconditions, \symexecution,  
%% \trees)$, where
%% \begin{itemize}
%% \item $\symstates$ is the set of (partially) symbolic states : $\{(\variable_0,\symvalue), (\variable_1,\symvalue), \ldots, (\variable_n,\symvalue)\}$
%% \item $\rootsymstate \in \symstates$
%% \item $\symexecution: \{\symstates,\pathcondition\}
%%   \times \{\syminputs\} \rightarrow \trees$
%% \item $\pathconditions$
%% \item $\symalphabet$ The alphabet of symbols that appear in symbolic expressions
%%   and symbolic assignments.
%% \item $\trees$ The set of trees $\tree = \{E,\nodes\}$. Each tree is a binary tree of nodes.
%% \end{itemize}


%% \begin{itemize}
%% \item $\pathcondition \in \pathconditions$ is the path condition of a particular node of a tree.
%% \item $\pathconditions \subseteq \mathrm{symexpressions}$ Path condition is a subtype of
%%   symexpressions. The set of all path conditions is a subset of the set of all
%%   symexpressions.
%% \item $\nodes: \{\symstate,\pathcondition\}$, where $\symstate \in \symstates$
%%   and $\pathcondition \in \pathconditions$.
%% \item $\syminputs: <(\inputvariable_0, \symexpression), (\inputvariable_1,
%%   \symexpression), \ldots, (\inputvariable_m, \symexpression)>$
%% \end{itemize}



%% We model the program to be symbolically executed
%% S = {(reg_0, symexpr_0), (reg_1, symexpr_1), ..., (reg_n, symexpr_n)} (edited)
%% symInp = {(inp_0, symexpr_0), (inp_1, symexpr_1), ..., (inp_k, symexpr_k)} (edited)
%% Inp = {(inp_0, inpval_0), (inp_1, inpval_1), ..., (inp_k, inpval_k)} (edited)
%% C = {(reg_0, concval_0), (reg_1, concval_1), ..., (reg_n, concval_n)}

\subsection{Properties of Symbolic Execution}
King formalized the use of symbolic execution~\cite{king1976symbolic} and describes three
properties provided by symbolic execution. We name and summarize the properties
here.
\setcounter{property}{0}
\renewcommand{\theproperty}{K.\arabic{property}}
\begin{property}[Sound Paths]
  \label{prop:kingsound}
  The path condition $\pathcondition$ never becomes unsatisfiable. This means that for each
  leaf node the path condition $\pathcondition$ associated with that leaf node has at
  least one concrete valuation which would drive execution down the same path of
  execution.
  
  We express this the following way: 
  
  \begin{align*}
  \forall a = \mathtt{maptoalph}(\mathrm{alphabet}), & n =
\mathtt{intree}(\symexecution(\symstate,\syminput)), \\
 & \mathtt{simplify}(\mathtt{plugin}(n.\pathcondition,a) = \texttrue.
  \end{align*}
  
\end{property}


\begin{property}[Unique Paths]
  \label{prop:kingunique}
The path condition $\pathcondition_1$ and $\pathcondition_2$ associated with any two paths of the
tree are mutually unsatisfiable. In other words, there exists no concrete
valuation that could drive execution down two distinct paths of the symbolic
execution tree.

We express this the following way: 

\begin{align*}
\forall a = \mathtt{maptoalph}(\mathrm{alphabet}), &  n_1 n_2 =
\mathtt{intree}(\symexecution(\symstate,\syminput)) \\
& \wedge
n_1 \neq n_2 \\
&  \wedge
(\mathtt{ischildof}(n_1, n_2) \vee  \mathtt{ischildof}(n_2, n_1))= \textfalse \\
&\rightarrow \mathtt{simplify}(\mathtt{plugin}(l.\pathcondition,a) = \textfalse
\end{align*}
\end{property}

\begin{property}[Commutativity]

  We define some functions.
  \begin{itemize}
  \item maptoalph: $\{\symalphabet\} \rightarrow \{\concvalue\}$
  \item plugin: $\{\symexpression\} \times \{\concvalue\} \rightarrow
    \{\concexpression\}$
  \item simplify: $\{\concexpression\} \rightarrow \{\concvalue\}$
  \end{itemize}




\begin{align*}
\forall a = \mathtt{maptoalph}(\mathrm{alphabet}), & l =
\mathtt{isleaf}(\symexecution(\symstate,\syminput)) \wedge
\mathtt{simplify}(\mathtt{plugin}(l.\pathcondition,a) = \texttrue \\
&\rightarrow \mathtt{simplify}(\mathtt{plugin}(l.\symstate,a)) = \\
&\qquad\concexecution(\mathtt{simplify}(\mathtt{plugin}(\symstate)),\mathtt{simplify}(\mathtt{plugin}(\syminput)))
\end{align*}
\end{property}



