\section{Proof Strategy}
The claim made by Zhang and Sturton is that a sequence of symbolic execution
trees that abides by the three requirements will yield a set of sequences of concrete
input values, each of which will take the hardware module from the reset state to an
error state.

We prove that if a sequence of trees produced by our abstract Coq model of symbolic
execution, which is based on the three King properties (Properties
\ref{prop:kingsound}, \ref{prop:kingunique}, \ref{prop:kingcommutativity}), abides by
Properties~\ref{prop:startinit}, \ref{prop:correctedz2}, and \ref{prop:stitch}, then
it does yield a set of sequences of concrete inputs that take the abstract Coq model of
concrete execution from the reset state to an error state.

%% We show that given a Coq model of both symbolic execution and the backwards symbolic execution tool and a set of properties, 
%% the backwards symbolic execution tool will give us a list of symbolic execution trees with corresponding leaves that, when executed, will result in an error state.

%% In other words, we define a list of symbolic execution trees, called \textit{tree\_list}, the we bind with a set of properties and a method to execute the relevant leaves, called \textit{execute\_tree\_list},
%% and show that it leads to a set of error states, called \textit{error\_states}. This can be expressed as the following theorem


\begin{theorem}[Correctness of Recursive Strategy]
\label{thm:sufficiency} Consider a sequence of $n$ trees $\mathit{tree\_list} =
t_0, t_1, \ldots, t_{n-1}$, where each tree satisfies King
Properties~\ref{prop:kingsound}-\ref{prop:kingcommutativity}. If
$\mathit{tree\_list}$ satisfies the requirements \ref{prop:startinit},
\ref{prop:correctedz2}, \ref{prop:stitch}, then \cks{Finish this sentence. I
  think we need to formally define execute tree list prior to this and then we
  can use it here, or else formally define correctness and then use that term here.}
%%$execute\_tree\_list (tree\_list) \in error\_states$.
\end{theorem}
 
 In order to prove this, we first prove the following theorem:

\begin{theorem}[Execution ends in leaf of the last tree]
\label{thm:etl}
 $execute\_tree\_list (tree\_list) \in concretize\_leaf (t)$, where $t$ is the last element of $tree\_list$.
\end{theorem}

We then show that $concretize\_leaf (t) \in error\_states$, giving us our result.

We prove Theorem \ref{thm:etl} by induction. 
For our base case, we show that if the list only contains one tree, execution of that tree's root node with input specified by a selected leaf will result in an element of $concretize\_leaf (t)$.

\begin{figure}
\centering
\includegraphics[width=.8\textwidth]{set3.eps}
\caption{Visual depiction of the base case of the proof.}
\label{fig:basecase}
\end{figure}

In other words, as depicted in Figure \ref{fig:basecase}, we show that the initial state is an element of $concretize\_root(t)$ of the tree, $t$, and that concretely executing any element of $concretize\_root(t)$ will result n an element inside $concretize\_leaf(t).$



For our inductive step, as depicted in Figures  \ref{fig:tlist} and \ref{fig:indstep}, we show that execution of each root with inputs from each specified leaf in a tree list of size $n$ will result in an element of $concretize\_leaf(t_n)$.

Our inductive hypothesis is that $execute\_tree\_list (tree\_list') \in concretize\_leaf (t_{n-1})$, where $tree\_list'$ is a $tree\_list$ with the last element removed. We then show that $concretize\_leaf (t_{n-1}) \subseteq concretize\_root (t_{n}) $, and therefore the concrete execution of any element in $concretize\_leaf (t_{n-1}) $ is in the set of of the concrete execution of any element in $concretize\_root (t_{n})$. Next, we show that $concretize\_root (t_{n}) \subseteq concretize\_leaf (t_{n})$, giving us our result.
 
\begin{figure}
\centering
\includegraphics[width=.8\textwidth]{tlist.eps}
\caption{List of trees of length $n$.}
\label{fig:tlist}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=.8\textwidth]{set4.eps}
\caption{Visual depiction of the inductive step of the proof.}
\label{fig:indstep}
\end{figure}

The reason we need Property $2'$ is because Property $2$ is not sufficient. 
This is because if $\mathtt{execute\_tree\_list} (tree\_list) \in \mathtt{concretize\_leaf} (\mathtt{last\_element}(tree\_list))$ and \\
$\mathtt{concretize\_leaf} (\mathtt{last\_element} (tree\_list)) \cap error\_states \neq \{\}$, we could get the case where
$\mathtt{execute\_tree\_list} (tree\_list) \notin error\_states$, as shown in Figure \ref{fig:Prop2}.

\begin{figure}
  \centering
\includegraphics[width=.4\textwidth]{prop2.eps}
\caption{Example of Property $2$ not being sufficient to show $\mathtt{execute\_tree\_list} (tree\_list) \in error\_states$.}
\label{fig:Prop2}
\end{figure}
