\section{Proof Strategy}
The claim made by Zhang and Sturton is that a sequence of symbolic execution
trees that abides by the three requirements will yield a set of sequences of concrete
input values, each of which will take the hardware module from the reset state to an
error state.

We prove that if a sequence of trees produced by our abstract Coq model of symbolic
execution, which is based on the three King properties (Properties
\ref{prop:kingsound}, \ref{prop:kingunique}, \ref{prop:kingcommutativity}), abides by
Properties~\ref{prop:startinit}, \ref{prop:correctedz2}, and \ref{prop:stitch}, then
it does yield a set of sequences of concrete inputs that take the abstract Coq model of
concrete execution from the reset state to an error state.


We start by formally proving the following lemma, which we will use in our proof:
\begin{lemma} \label{cop}
forall symbolic states $s$, symbolic inputs $i'$, concrete states $c$, and $m = \mathtt{map(\cdot)}$,
if $cs \in \mathtt{concretize\_root}(t)$,
then 
$conc\_ex(cs, \mathtt{get\_input} ($i'$)) \in \mathtt{concretize\_leaf}(t)$,
where $l$ is a leaf of $t$ and $t = $ \symexecution($s, i'$).
\end{lemma}

\cks{Alyssa, what does the above lemma say? And where in the proof is it used?} In order to prove this, we utilize the commutativity property expressed earlier.

%% Our main correctness theorem that we prove is Theorem \ref{thm:sufficiency}. In other words, given our three property requirements, executing our tree\_list will get us to an error state.


%% We show that given a Coq model of both symbolic execution and the backwards symbolic execution tool and a set of properties, 
%% the backwards symbolic execution tool will give us a list of symbolic execution trees with corresponding leaves that, when executed, will result in an error state.

%% In other words, we define a list of symbolic execution trees, called \textit{tree\_list}, the we bind with a set of properties and a method to execute the relevant leaves, called \textit{execute\_tree\_list},
%% and show that it leads to a set of error states, called \textit{error\_states}. This can be expressed as the following theorem


\begin{theorem}[Correctness of Recursive Strategy]
\label{thm:sufficiency} Consider a sequence of $n$ trees $\mathit{tree\_list} =
t_0, t_1, \ldots, t_{n-1}$, where each tree satisfies King
Properties~\ref{prop:kingsound}-\ref{prop:kingcommutativity}. If
$\mathit{tree\_list}$ satisfies the requirements \ref{prop:startinit},
\ref{prop:correctedz2}, \ref{prop:stitch}, then \cks{Finish this sentence. I
  think we need to formally define execute tree list prior to this and then we
  can use it here, or else formally define correctness and then use that term here.}
%%$execute\_tree\_list (tree\_list) \in error\_states$.
\end{theorem}
 
 In order to prove this, we first prove the following theorem:

\begin{theorem}[Execution ends in leaf of the last tree]
\label{thm:etl}
 $execute\_tree\_list (tree\_list) \in concretize\_leaf (t)$, where $t$ is the last element of $tree\_list$.
\end{theorem}

We then show that $concretize\_leaf (t) \in error\_states$, giving us our result.

We prove Theorem \ref{thm:etl} by induction. 
For our base case, we show that if the list only contains one tree, execution of that tree's root node with input specified by a selected leaf will result in an element of $concretize\_leaf (t)$.

\begin{figure}
\centering
\includegraphics[width=.8\textwidth]{set3.eps}
\caption{Visual depiction of the base case of the proof.}
\label{fig:basecase}
\end{figure}

In other words, as depicted in Figure \ref{fig:basecase}, we show that the initial state is an element of $concretize\_root(t)$ of the tree, $t$, and that concretely executing any element of $concretize\_root(t)$ will result n an element inside $concretize\_leaf(t).$



For our inductive step, as depicted in Figures  \ref{fig:tlist} and \ref{fig:indstep}, we show that execution of each root with inputs from each specified leaf in a tree list of size $n$ will result in an element of $concretize\_leaf(t_n)$.

Our inductive hypothesis is that $execute\_tree\_list (tree\_list') \in concretize\_leaf (t_{n-1})$, where $tree\_list'$ is a $tree\_list$ with the last element removed. We then show that $concretize\_leaf (t_{n-1}) \subseteq concretize\_root (t_{n}) $, and therefore the concrete execution of any element in $concretize\_leaf (t_{n-1}) $ is in the set of of the concrete execution of any element in $concretize\_root (t_{n})$. Next, we show that $concretize\_root (t_{n}) \subseteq concretize\_leaf (t_{n})$, giving us our result.
 
\begin{figure}
\centering
\includegraphics[width=.8\textwidth]{tlist.eps}
\caption{List of trees of length $n$.}
\label{fig:tlist}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=.8\textwidth]{set4.eps}
\caption{Visual depiction of the inductive step of the proof.}
\label{fig:indstep}
\end{figure}




The reason we need Property $2'$ is because Property $2$ is not sufficient. 
This is because if $\mathtt{execute\_tree\_list} (tree\_list) \in \mathtt{concretize\_leaf} (\mathtt{last\_element}(tree\_list))$ and \\
$\mathtt{concretize\_leaf} (\mathtt{last\_element} (tree\_list)) \cap error\_states \neq \{\}$, we could get the case where
$\mathtt{execute\_tree\_list} (tree\_list) \notin error\_states$, as shown in Figure \ref{fig:Prop2}.

\begin{figure}
  \centering
\includegraphics[width=.4\textwidth]{prop2.eps}
\caption{Example of Property $2$ not being sufficient to show $\mathtt{execute\_tree\_list} (tree\_list) \in error\_states$.}
\label{fig:Prop2}
\end{figure}
