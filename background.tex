\section{Background}
\cks{SE w/formalization; statement of King properties; SE for HW; explanation of
  RecSE; statement of 3 RecSE properties}
\subsection{Symbolic Execution}
In symbolic execution the final parameters to a program's entry point are
assigned symbolic values. The symbolic execution engine simulates each line of
code, using the symbolic values in place of the usual concrete literals. As
execution continues the resulting symbolic expressions propagate throughout the program's
state. The symbolic execution engine
maintains the current, partially symbolic state of the program and the current
\emph{path condition}. The path condition is a conjunction of propositions over
input and state variables that define the path through the program code taken to
reach the current state. Figure~\ref{fig:se} demonstrates the idea. 

For example, for the code in
Figure~\ref{fig:sea}, if $\mathtt{reset}$ and $\mathtt{count}$ are initialized
with the symbolic values $r_0$ and $c_0$, respectively, then after symbolically
executing lines 1, 3, and 4 count may be set to the symbolic expression $c_0 +
1$ as shown in Figure~\ref{fig:sec}. In addition to the (partially) symbolic
state that is maintained, a symbolic execution engine keeps track of the
\emph{path condition}. The path condition is a conjunction of propositions that
accrue at each conditional branch point in the program. There is one path
condition per path of execution through the code. In Figure~\ref{fig:sec} the
path condition for the path through lines 1, 3, 4, 5, 6 is shown. When execution
reaches the $\mathtt{ERROR}$ at line 6 the path condition is $\mathit{pc} := r_0
== 0 \wedge c_0 + 1 > 3$. This expression can then be solved using a standard,
off-the-shelf SMT solver to find a satisfying solution, say $r_0 := 0$ and $c_0
:= 3$. Substituting these values for $\mathtt{reset}$ and $\mathtt{count}$,
respectively and executing the code concretely could cause execution to follow
the same path as was followed symbolically.

\cks{Brain dump a bunch of mostly terrible text to get started.}
We model the processor as a vector $R$ of state registers $R = <r_0, r_1,
\ldots, r_n>$. At each step of execution (clock cycle) the valuation of each
register may change. New state is determined by the Boolean and bitvector
arithmetic combination of current state plus input values. $\forall m, r'_m =
\delta(R,I)$.

In concrete execution registers hold concrete values $(v_0, v_1, \ldots, v_n)$
at each clock cycle. In symbolic execution the concrete values are replaced with
symbolic values $(\phi_0, \phi_1, \ldots, \phi_n)$ and so are input values.
As execution continues, symbolic values propagate through the design.

The symbolic state is modeled as a tuple $\psi := (S,\pi)$ where $S$ is the
vector of registers containing a combination of symbolic and concrete state $S
:= <s_0, s_1, \ldots, s_n>$. As execution continues, symbolic values propagate
through the design.

When execution begins the path constraint is initialized to $\mathtt{\textsc{true}}$. At
each conditional branch the condition $c$ is evaluated. If $\pi \rightarrow c$
the $\mathtt{then}$ branch is taken and the path constraint is
updated $\pi := \pi \wedge c$. If $\pi \rightarrow \not c$ the $\mathtt{else}$
branch is taken and the path constraint is updated $\pi := \pi \wedge \not
c$. If neither $\pi \rightarrow c$ nor $\pi \rightarrow \not c$ hold, then both
branches are possible. Execution forks and both branches are explored in turn
with the path condition updated appropriately for each branch.
\cks{Need to introduce trees}

King formalized the use of symbolic execution~\cite{??} and describes three
properties provided by symbolic execution. We name and summarize the properties
here.
\begin{property}[Sound Paths]
  \label{prop:kingsound}
  The path constraint $\pi$ never becomes unsatisfiable. This means that at each
  leaf node the path constraint $\pi$ assoicated with that leaf node has at
  least one concrete valuation which would drive execution down the same path of
  execution.
\end{property}
\begin{property}[Unique Paths]
  \label{prop:kingunique}
The path constraints $\pi_1$ and $\pi_2$ associated with any two paths of the
tree are mutually unsatisfiable. In other words, there exists no concrete
valuation that could drive execution down two distinct paths of the symbolic
execution tree.
\end{property}
\begin{property}[Commutativity]
  \cks{Todo}
\end{property}

\subsection{Symbolic Execution of Hardware Designs}

\subsection{Using Coq as a Verification Tool}
Coq is a formal, interactive proof assistant that allows for machine-checked proofs of systems. 
It implements the inductive language Gallina. It allows for formal definitions of systems, and assists the user in building machine-checkable proofs. If the proof is complete, it will compile.

There are four main structures in Coq that we use in our proof:
\begin{itemize}
\item \emph{Axiom} is used to express properties that do not need to be proven. These are meant to be accepted as ground truth in the system. 
\item \emph{Definition} and \emph{Fixpoint} are used to define methods.
\item \emph{Variable} defines local variables.
\item \emph{Theorem} expresses a property that needs to be proven.

\end{itemize}

For our system, we express the properties of symbolic execution as axioms because we are assuming they are true. Additionally, we express the recursive symbolic execution tool's properties as axioms because these are defined as requirements. Our definitions and fixpoints are the methods that are implemented in the system, such as execution of the list of trees provided by the recursive symbolic execution tool. Variables are system-specific variables, such as the initial state and the error states. The properties we want to prove about the tool are expressed as theorems.





