\section{Background}
\cks{SE w/formalization; statement of King properties; SE for HW; explanation of
  RecSE; statement of 3 RecSE properties}
\subsection{Symbolic Execution}
In symbolic execution formal final parameters to a program's entry point are
assigned symbolic values. A symbolic execution engine simulates each line of
code, using the symbolic values in place of the usual concrete literals. As
execution continues the resulting symbolic expressions propagate throughout the program's
state.

When execution reaches a conditional branch, the symbolic execution
engine determines whether the current, partially symbolic state could satisfy
either the branch condition or its negation. If only one branch is possible,
execution continues down that branch. If both branches are possible for the
current symbolic state, execution forks and each branch is explored in turn.

The execution engine keeps track of the \emph{path condition} \pc for each path
taken through the code. When execution begins the path condition is initialized
to \texttrue. At each conditional branch the condition $c$ is evaluated. If $\pc
\rightarrow c$ the $\mathtt{then}$ branch is taken and the path constraint is
updated $\pc := \pc \wedge c$. If $\pc \rightarrow \neg c$ the $\mathtt{else}$
branch is taken and the path constraint is updated $\pc := \pc \wedge \neg
c$. If neither $\pc \rightarrow c$ nor $\pc \rightarrow \neg c$ hold, then both
branches are possible. Execution forks and both branches are explored in turn
with the path condition updated appropriately for each branch.

All the paths explored through the program form a logical tree \tree. The root represents the
program's entry point and each node of the
tree represents a line of code in the program. A path in the tree from root to leaf
represents a path of execution through the program.

The symbolic execution engine
maintains the current, partially symbolic state of the program and the current
\emph{path condition}. The path condition is a conjunction of propositions over
input and state variables that define the path through the program code taken to
reach the current state. Figure~\ref{fig:se} demonstrates the idea. 

For example, for the code in
Figure~\ref{fig:sea}, if $\mathtt{reset}$ and $\mathtt{count}$ are initialized
with the symbolic values $r_0$ and $c_0$, respectively, then after symbolically
executing lines 1, 3, and 4 count may be set to the symbolic expression $c_0 +
1$ as shown in Figure~\ref{fig:sec}. In addition to the (partially) symbolic
state that is maintained, a symbolic execution engine keeps track of the
\emph{path condition}. The path condition is a conjunction of propositions that
accrue at each conditional branch point in the program. There is one path
condition per path of execution through the code. In Figure~\ref{fig:sec} the
path condition for the path through lines 1, 3, 4, 5, 6 is shown. When execution
reaches the $\mathtt{ERROR}$ at line 6 the path condition is $\mathit{pc} := r_0
== 0 \wedge c_0 + 1 > 3$. This expression can then be solved using a standard,
off-the-shelf SMT solver to find a satisfying solution, say $r_0 := 0$ and $c_0
:= 3$. Substituting these values for $\mathtt{reset}$ and $\mathtt{count}$,
respectively and executing the code concretely could cause execution to follow
the same path as was followed symbolically.

\cks{Brain dump a bunch of mostly terrible text to get started.}
We model the processor as a vector $R$ of state registers $R = <r_0, r_1,
\ldots, r_n>$. At each step of execution (clock cycle) the valuation of each
register may change. New state is determined by the Boolean and bitvector
arithmetic combination of current state plus input values. $\forall m, r'_m =
\delta(R,I)$.

In concrete execution registers hold concrete values $(v_0, v_1, \ldots, v_n)$
at each clock cycle. In symbolic execution the concrete values are replaced with
symbolic values $(\phi_0, \phi_1, \ldots, \phi_n)$ and so are input values.
As execution continues, symbolic values propagate through the design.

The symbolic state is modeled as a tuple $\psi := (S,\pi)$ where $S$ is the
vector of registers containing a combination of symbolic and concrete state $S
:= <s_0, s_1, \ldots, s_n>$. As execution continues, symbolic values propagate
through the design.


King formalized the use of symbolic execution~\cite{??} and describes three
properties provided by symbolic execution. We name and summarize the properties
here.
\begin{property}[Sound Paths]
  \label{prop:kingsound}
  The path constraint $\pi$ never becomes unsatisfiable. This means that at each
  leaf node the path constraint $\pi$ assoicated with that leaf node has at
  least one concrete valuation which would drive execution down the same path of
  execution.
\end{property}
\begin{property}[Unique Paths]
  \label{prop:kingunique}
The path constraints $\pi_1$ and $\pi_2$ associated with any two paths of the
tree are mutually unsatisfiable. In other words, there exists no concrete
valuation that could drive execution down two distinct paths of the symbolic
execution tree.
\end{property}
\begin{property}[Commutativity]
  \cks{Todo}
\end{property}

\subsection{Symbolic Execution of Hardware Designs}

\subsection{Using Coq as a Verification Tool}
\cks{Alyssa, can you add more information about how Coq works, what is
  expressible in Coq, and what libraries we made use of?}
Coq is a formal, interactive proof assistant that allows for machine-checked proofs of systems. 
It implements the inductive language Gallina, which is based on the \textit{Calculus of Inductive Constructions}, a typed $\lambda$-calculus. It allows definitions of methods that can be evaluated, the expression of theorems and software specifications, and assists the user in building machine-checkable proofs. If the proof is complete, it will compile.


%There are four main structures in Coq that we use in our proof:
%\begin{itemize}
%\item \emph{Axiom} is used to express properties that do not need to be proven. These are meant to be accepted as ground truth in the system. 
%\item \emph{Definition} and \emph{Fixpoint} are used to define methods.
%\item \emph{Variable} defines local variables.
%\item \emph{Theorem} expresses a property that needs to be proven.
%\end{itemize}

 

Additionally, we make use of Coq's module system, representing different parts of our system as modules.  There is a module defining concrete execution, a module defining symbolic execution that includes the King properties as axioms, and a module defining the backwards symbolic execution tool that includes the tool requirements as axioms and the correctness property expressed as a theorem.

Our definitions and fixpoints are the methods that are implemented
in the system, such as execution of the list of trees provided by the recursive
symbolic execution tool. Our variables are system-specific variables, such as the
initial state and the error states, and they are contained in the backwards symbolic execution module as well.

We utilize the built-in ``logic'' library for assistance in small proofs and the ``ensembles'' library for assistance reasoning about finite sets. Additionally, we use the built-in ``list'' structure to represent lists of symbolic execution trees.


\cks{Rather than give these details about the syntax of Coq here, use the
  background section to provide the reader a sense of how Coq works with a focus
  on the features we make use of.}






