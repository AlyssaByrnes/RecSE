\section{Background}
\cks{SE w/formalization; statement of King properties; SE for HW; explanation of
  RecSE; statement of 3 RecSE properties}
Symbolic execution is a means of exploring many paths through a program
in order to find paths leading to an error state or bug. In symbolic execution
input variables to a program are given symbolic values. As the program executes
the symbolic values are used in place of the usual concrete literals and the
resulting symbolic expressions may propagate throughout the program's
state. Figure~\ref{fig:se} demonstrates the idea. For example, for the code in
Figure~\ref{fig:sea}, if $\mathtt{reset}$ and $\mathtt{count}$ are initialized
with the symbolic values $r_0$ and $c_0$, respectively, then after symbolically
executing lines 1, 3, and 4 count may be set to the symbolic expression $c_0 +
1$ as shown in Figure~\ref{fig:sec}. In addition to the (partially) symbolic
state that is maintained, a symbolic execution engine keeps track of the
\emph{path condition}. The path condition is a conjunction of propositions that
accrue at each conditional branch point in the program. There is one path
condition per path of execution through the code. In Figure~\ref{fig:sec} the
path condition for the path through lines 1, 3, 4, 5, 6 is shown. When execution
reaches the $\mathtt{ERROR}$ at line 6 the path condition is $\mathit{pc} := r_0
== 0 \wedge c_0 + 1 > 3$. This expression can then be solved using a standard,
off-the-shelf SMT solver to find a satisfying solution, say $r_0 := 0$ and $c_0
:= 3$. Substituting these values for $\mathtt{reset}$ and $\mathtt{count}$,
respectively and executing the code concretely could cause execution to follow
the same path as was followed symbolically.

\cks{Brain dump a bunch of mostly terrible text to get started.}
We model the processor as a vector $R$ of state registers $R = <r_0, r_1,
\ldots, r_n>$. At each step of execution (clock cycle) the valuation of each
register may change. New state is determined by the Boolean and bitvector
arithmetic combination of current state plus input values. $\forall m, r'_m =
\delta(R,I)$.

In concrete execution registers hold concrete values $(v_0, v_1, \ldots, v_n)$
at each clock cycle. In symbolic execution the concrete values are replaced with
symbolic values $(\phi_0, \phi_1, \ldots, \phi_n)$ and so are input values.
As execution continues, symbolic values propagate through the design.

The symbolic state is modeled as a tuple $\psi := (S,\pi)$ where $S$ is the
vector of registers containing a combination of symbolic and concrete state $S
:= <s_0, s_1, \ldots, s_n>$. As execution continues, symbolic values propagate
through the design.

When execution begins the path constraint is initialized to $\mathtt{True}$. At
each conditional branch the condition $c$


