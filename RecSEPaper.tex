\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\newtheorem{define}{Definition}
\newtheorem{property}{Property}
\newtheorem{lemma}{Lemma}
\newtheorem{cor}{Corollary}

\title{A Recursive Strategy for Symbolic Execution Expressed in Coq}
\author{Alyssa Byrnes}

\begin{document}
\maketitle

\begin{abstract}
Symbolic execution allows one to execute a program with symbolic inputs, rather than concrete ones, exploring multiple execution paths simultaneously. This can be a useful tool in debugging a system, for now we can potentially execute all possible inputs of a program to discover bugs and generate exploits. In this work, we examine a previously proposed hardware-oriented recursive symbolic execution algorithm and formally verify that if an error state is reachable, it produces a sequence of inputs that will take the processor from its inital state to that error state.
\end{abstract}


\section{Data Types}

\begin{itemize}

\item Object of type $\varphi$ to represent nodes on the symbolic execution tree.

\begin{itemize}
\item  get\_phi($n$)  returns $\phi$, the abstract state.
\item  get\_pc($n$) returns $\pi$, the path constraint.
\item $B =$ sym\_ex($A$), or $[A]_\sim \Rightarrow_{\mathcal{S}}^{S^*} [B]_\sim$, represents symbolic execution of state $A$ for one clock cycle, where $A$ and $B$ are of type $\varphi$.
\item unif($A$), or $[\![ A ]\!]$  represents the set of concrete states represented by symbolic state $A$. 

\end{itemize}
\item Object of type $\mathcal{E}$ to represent a symbolic execution tree made of objects of type $n$.
\begin{itemize}
\item  is\_leaf($\mathcal{E}$, $n$)  returns $true$ if $n$ is a leaf in $\mathcal{E}$.
\item is\_root($\mathcal{E}$, $n$) returns $true$ if $n$ is the root in $\mathcal{E}$.
\item get\_root($\mathcal{E}$)  returns object of type $n$ that is the root of the tree.

\end{itemize}


\item Object of type $\gamma$ to represent concrete state.
\begin{itemize}
\item $B =$ conc\_ex($A$), or $A \Rightarrow_{\mathcal{S}}^* B$, represents concrete execution of state $A$ for one clock cycle, where $A$ and $B$ are of type $\gamma$.

\end{itemize}
\item Object $E$ to represent set of concrete states.
\begin{itemize}
\item Contains set of initial configuration states $\mathcal{T}_{\mathit{Cfg}}$.
\end{itemize}
\end{itemize}


\subsection*{Shorthand:}
\begin{itemize}
\item $\bar{s}_{r,m} =$ get\_phi(get\_root($\mathcal{E}_m$)) 
\item $\pi_{r,m} =$ get\_pc(get\_root($\mathcal{E}_m$)) 
\item $ \bar{s}_{l,m} =$ get\_phi($n_{l,m}$), where $n_{l,m} \in \mathcal{E}_m$.
\item $ \pi_{l,m} =$ get\_pc($n_{l,m}$), where $n_{l,m} \in \mathcal{E}_m$.
\end{itemize}

\section{Accepted Knowledge}
These are the properties outlined in Arusoaie et al.'s paper \cite{arusoaie2013generic}.
\begin{lemma}
If $\gamma \Rightarrow_{\mathcal{S}} \gamma'$, and $\gamma \in [\![\varphi ]\!]$, then there exists $\varphi'$ such that $\gamma' \in [\![\varphi' ]\!]$ and $[\varphi]_{\sim} \Rightarrow_{\mathcal{S}}^S [\varphi']_{\sim}$.
\cite{arusoaie2013generic}
\end{lemma}

\begin{cor}
For every concrete execution $\gamma_0  \Rightarrow_{\mathcal{S}} \gamma_1  \Rightarrow_{\mathcal{S}} \ldots \gamma_n  \Rightarrow_{\mathcal{S}} \ldots$, and pattern $\varphi_0$ such that $\gamma_0 \in [\![\varphi_0 ]\!]$, there exists a symbolic execution $[\varphi_0]_{\sim} \Rightarrow_{\mathcal{S}}^S [\varphi_1]_{\sim} \Rightarrow_{\mathcal{S}}^S \ldots [\varphi_n]_{\sim} \Rightarrow_{\mathcal{S}}^S \ldots $ such that $\gamma_i \in [\![\varphi_i ]\!]$ for all $i = 0, 1, \ldots$.
\cite{arusoaie2013generic}
\end{cor}

\begin{lemma}
If $\gamma' \in [\![\varphi' ]\!]$ and $[\varphi]_{\sim} \Rightarrow_{\mathcal{S}}^S [\varphi']_{\sim}$ then there exists $\gamma \in \mathcal{T}_{\mathit{Cfg}}$ such that $\gamma \Rightarrow_{\mathcal{S}} \gamma'$ and $\gamma \in [\![\varphi]\!]$.
\cite{arusoaie2013generic}
\end{lemma}

\begin{cor}
For every feasible symbolic execution $[\varphi_0]_{\sim} \Rightarrow_{\mathcal{S}}^S [\varphi_1]_{\sim} \Rightarrow_{\mathcal{S}}^S \ldots [\varphi_n]_{\sim} \Rightarrow_{\mathcal{S}}^S \ldots $ there is a concrete execution $\gamma_0  \Rightarrow_{\mathcal{S}} \gamma_1  \Rightarrow_{\mathcal{S}} \ldots \gamma_n  \Rightarrow_{\mathcal{S}} \ldots$ such that $\gamma_i \in [\![\varphi_i ]\!]$ for all $i = 0, 1, \ldots$.
\cite{arusoaie2013generic}
\end{cor}


Lemma $1$ states that all concrete states have corresponding symbolic representations, and Lemma $2$ states that if a program symbolically executes to a set of possible concrete assignments, then initial concrete assignments exist so the program can concretely execute to that state.

Corollaries $1$ and $2$ lift this definition to a consecutive sequence of executions. From here on, a sequence symbolic executions of an unbounded, finite length, $[\varphi_0]_{\sim} \Rightarrow_{\mathcal{S}}^S [\varphi_1]_{\sim} \Rightarrow_{\mathcal{S}}^S \ldots [\varphi_n]_{\sim}$ will be denoted by $[\varphi_0]_{\sim} \Rightarrow_{\mathcal{S}}^{S^*} [\varphi_n]_{\sim} $. A sequence of concrete executions of an unbounded, finite length, $\gamma_0  \Rightarrow_{\mathcal{S}} \gamma_1  \Rightarrow_{\mathcal{S}} \ldots \gamma_n  \Rightarrow_{\mathcal{S}}$ will be denoted by $\gamma_0   \Rightarrow_{\mathcal{S}}^{*}  \gamma_n $

\section{Circle Operations}
These use the notation defined in Arusoaie et al.'s paper \cite{arusoaie2013generic}.

\begin{define}
circle\_op\_1 = the set $\gamma \in [\![\varphi ]\!] $ $\forall$  $\gamma' \in [\![\varphi' ]\!]$ of a given $\varphi'$ where $[\varphi]_{\sim} \Rightarrow_{\mathcal{S}}^{S^*} [\varphi']_{\sim}$ such that $\gamma \Rightarrow_{\mathcal{S}}^* \gamma'$ and is\_leaf($\varphi'$)$ = true$.
\end{define}

\begin{define}
circle\_op\_2 = the set $\gamma' \in [\![\varphi' ]\!] $ $\forall$  $\gamma \in [\![\varphi ]\!]$ of a given $\varphi$ where $[\varphi]_{\sim} \Rightarrow_{\mathcal{S}}^S [\varphi']_{\sim}$ such that $\gamma \Rightarrow_{\mathcal{S}} \gamma'$ and is\_leaf($\varphi'$)$ = true$.
\end{define}


circle\_op\_1 represents all concrete states that will take us down exactly one path in the symbolic execution tree. circle\_op\_2 represents all concrete output states of a given path in the symbolic execution tree.

\section{Properties}
For a given $E, X = $ a sequence $\mathcal{E}_0, ..., \mathcal{E}_m$ such that $\forall \mathcal{E}_x$, $\exists n_{l,x}$ such that the conjunction of the following is true:
\begin{enumerate}
\item $s_0 \in$ circle\_op\_1($\bar{s}_{r,0} $, $\pi_{l,0}$)
\item $E \bigcap$ circle\_op\_2($\bar{s}_{l,m} $, $\pi_{l,m}$) $\neq \{\}$
\item for $j = \{0,...,m-1\}$, circle\_op\_2($\bar{s}_{l,j} $, $\pi_{l,j}$) $\subseteq$ circle\_op\_1($\bar{s}_{r,j+1} $, $\pi_{l,j+1}$)
\item is\_leaf($\mathcal{E}_x$, $n_{l,x}$) $= true$.
\end{enumerate}
\section{To Do}
\begin{itemize}
\item Reason about equivalence class, and how the notation transfers to our notation.
\item Representing unification in Coq.
\item Representing sequences in Coq.
\item Representing sufficiency requirement in Coq.
\item Representing ``equivalence'' of concrete states.

\end{itemize}

\section{Notes for Consideration}
\begin{itemize}
\item We need to consider uniqueness. This might come naturally from the overall tree structure.
\item Our work assumes SAT-solver correctness.
\item Our circle\_op returns concrete states, so we just need to be able to compare concrete states.
\end{itemize}

\bibliographystyle{alpha}
\bibliography{references}

\end{document}