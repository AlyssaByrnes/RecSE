\documentclass[a4paper]{article}

%% Language and font encodings
%\usepackage[english]{babel}
%\usepackage[utf8x]{inputenc}
%usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\newtheorem{define}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{property}{Property}
\newtheorem{lemma}{Lemma}
\newtheorem{cor}{Corollary}

\title{A Recursive Strategy for Symbolic Execution Expressed in Coq}
\author{A. Byrnes and C. Sturton}

\begin{document}
\maketitle

\begin{abstract}
Symbolic execution allows one to execute a program with symbolic inputs, rather
than concrete ones, exploring multiple execution paths simultaneously. This can
be a useful tool in debugging a system, for now we can potentially execute all
possible inputs of a program to discover bugs and generate exploits. In this
work, we examine a previously proposed hardware-oriented recursive symbolic
execution algorithm and formally verify that if an error state is reachable, it
produces a sequence of inputs that will take the processor from its inital state
to that error state. \cite{test}
\end{abstract}

\section{Introduction}
\section{Prior Work}
\section{System Framework}
\section{Verification Approach}
\section{Conclusion and Future Work}

\input scraptext
%% \input introduction
%% \input background
%% \input proofdesign
%% \input relatedwork
%% \input conclusion


\bibliographystyle{alpha}
\bibliography{references}

\end{document}
