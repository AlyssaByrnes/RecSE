\documentclass[runningheads]{llncs}

%% Language and font encodings
%\usepackage[english]{babel}
%\usepackage[utf8x]{inputenc}
%usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{bmpsize}
%\usepackage{subfig}
\usepackage{subcaption}

%\newtheorem{define}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{axiom}{Axiom}
%\newtheorem{lemma}{Lemma}
%\newtheorem{cor}{Corollary}

\spnewtheorem{mydefinition}[definition]{Definition}{\bfseries}{\rmfamily}

\newcommand{\cks}[1]{\textcolor{red}{cks: #1}}
\newcommand{\ab}[1]{\textcolor{cyan}{ab: #1}}

%% Paper specific commands
%Concrete
\newcommand{\texttrue}{\ensuremath{\mathtt{\textsc{true}}}}
\newcommand{\textfalse}{\ensuremath{\mathtt{\textsc{false}}}}

\newcommand{\hardwaredesign}{\ensuremath{H}}
\newcommand{\registers}{\ensuremath{R}}
\newcommand{\concstates}{\ensuremath{C}} %%Delete?
\newcommand{\concstate}{\ensuremath{c}} %%Delete?
\newcommand{\concexecution}{\ensuremath{\mathrm{concEx}}}
\newcommand{\assignments}{\ensuremath{A}}
\newcommand{\assignment}{\ensuremath{a}}
\newcommand{\init}{\ensuremath{\mathit{init}}}
\newcommand{\concinputs}{\ensuremath{I}} %%Delete?
\newcommand{\concinput}{\ensuremath{i}} %%Delete?
\newcommand{\inputsignals}{\ensuremath{I}}
\newcommand{\inputsignal}{\ensuremath{\mathit{inp}}}
\newcommand{\variable}{\ensuremath{v}}
\newcommand{\variables}{\ensuremath{V}}
\newcommand{\concvalue}{\ensuremath{x}}
\newcommand{\concexpression}{\ensuremath{e}}
%Symbolic
\newcommand{\symbolicexecutionengine}{\ensuremath{M}}
\newcommand{\symstates}{\ensuremath{\Sigma}}
\newcommand{\rootsymstate}{\ensuremath{\sigma_0}}
\newcommand{\symstate}{\ensuremath{\sigma}}
\newcommand{\symvalue}{\ensuremath{\sigma}} %%Delete?
\newcommand{\syminputs}{SymInputs}
\newcommand{\syminput}{\ensuremath{\alpha}}
\newcommand{\symexecution}{\ensuremath{\mathrm{symEx}}}
\newcommand{\pathconditions}{\ensuremath{\Pi}}
\newcommand{\pathcondition}{\ensuremath{\pi}}
\newcommand{\symalphabet}{\ensuremath{\Sigma}}
\newcommand{\trees}{\ensuremath{\mathcal{T}}}
\newcommand{\tree}{\ensuremath{T}}
\newcommand{\nodes}{\ensuremath{N}}
\newcommand{\symexpression}{\ensuremath{e}}


\begin{document}

\title{A Recursive Strategy for Symbolic Execution Expressed in Coq}
\author{A. Byrnes and C. Sturton}

%%\authorrunning{F. Author et al.}

\institute{University of North Carolina at Chapel Hill Department of Computer Science, \\  201 S Columbia St, Chapel Hill, NC 27599 \\
\email{\{abyrnes1,csturton\}@cs.unc.edu}}


\maketitle

\begin{abstract}
Prior work has proposed the use of symbolic execution for the security
validation of a processor design. The approach uses a recursive search strategy
that is designed to counter the combinatorial explosion of paths inherent in multi-cycle
processor execution. In this work, we examine the search strategy in order to
prove its correctness. We first formulate an abstract model of symbolic
execution in Coq. We then implement the recursive search strategy, and we find that the
strategy as proposed is not guaranteed to be sound---that is, the
search may find a symbolic path for which no concrete path from the processor's initial state
to the searched-for error state exists. We tighten one of the requirements of the
search strategy and then prove the modified strategy correct. 
\end{abstract}

\input{introduction}
\input{priorwork}
\input{background}
\input{definitions}
\input{ProofStrategy}
%\input{serep}
\input{systemrep}
\input{verificationapproach}
\input{conclusion}

%\input scraptext
%% \input introduction
%% \input background
%% \input proofdesign
%% \input relatedwork
%% \input conclusion


\bibliographystyle{splncs04}
\bibliography{references}

\end{document}
