\documentclass[runningheads]{llncs}

%% Language and font encodings
%\usepackage[english]{babel}
%\usepackage[utf8x]{inputenc}
%usepackage[T1]{fontenc}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{bmpsize}

\newtheorem{define}{Definition}
\newtheorem{thm}{Theorem}
\newtheorem{axiom}{Axiom}
%\newtheorem{lemma}{Lemma}
%\newtheorem{cor}{Corollary}

\newcommand{\cks}[1]{\textcolor{red}{cks: #1}}
\newcommand{\ab}[1]{\textcolor{cyan}{ab: #1}}

%% Paper specific commands
\newcommand{\pc}{\ensuremath{\mathit{pc}}}
\newcommand{\texttrue}{\ensuremath{\mathtt{\textsc{true}}}}
\newcommand{\tree}{\ensuremath{T}}
\newcommand{\hardwaredesign}{\ensuremath{P}}
\newcommand{\concstates}{\ensuremath{C}}
\newcommand{\concexecution}{\ensuremath{\mathrm{concEx}}}
\newcommand{\concinputs}{\ensuremath{I}}
\newcommand{\variable}{\ensuremath{v}}
\newcommand{\concvalue}{\ensuremath{x}}
\newcommand{\inputvariable}{\ensuremath{i}}
\newcommand{\symbolicexecutionengine}{\ensuremath{M}}
\newcommand{\symstates}{\ensuremath{S}}
\newcommand{\rootsymstate}{\ensuremath{s_0}}
\newcommand{\symexecution}{\ensuremath{\mathrm{symEx}}}
\newcommand{\pathconditions}{\ensuremath{\mathit{PC}}}
\newcommand{\pathcondition}{\ensuremath{\mathit{pc}}}
\newcommand{\symalphabet}{\ensuremath{\Sigma}}
\newcommand{\trees}{\ensuremath{T}}
\newcommand{\symvalue}{\ensuremath{\sigma}}
\newcommand{\syminputs}{SymInputs}

\begin{document}

\title{A Recursive Strategy for Symbolic Execution Expressed in Coq}
\author{A. Byrnes and C. Sturton}

%%\authorrunning{F. Author et al.}

\institute{University of North Carolina at Chapel Hill Department of Computer Science, \\  201 S Columbia St, Chapel Hill, NC 27599 \\
\email{\{abyrnes1,csturton\}@cs.unc.edu}}


\maketitle

\begin{abstract}
Prior work has proposed the use of symbolic execution for the security
validation of a processor design. The approach uses a recursive search strategy
that is designed to counter the exponential path growth inherent in multi-cycle
processor execution. In this work, we examine the search strategy in order to
prove its correctness. We formulate an abstract model of symbolic execution with
the recursive search strategy in Coq, and we find that the
strategy as proposed is not guaranteed to be sound---that is, the
search may find a symbolic path for which no concrete path from the processor's initial state
to the given error state exists. We tighten one of the requirements of the
search strategy and make explicit an unstated assumption of the strategy. We then prove the modified strategy correct. 
\end{abstract}

\input{introduction}
\input{priorwork}
\input{background}
\input{ProofStrategy}
\input{serep}
\input{systemrep}
\input{verificationapproach}
\input{conclusion}

%\input scraptext
%% \input introduction
%% \input background
%% \input proofdesign
%% \input relatedwork
%% \input conclusion


\bibliographystyle{alpha}
\bibliography{references}

\end{document}
