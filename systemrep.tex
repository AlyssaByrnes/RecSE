\subsection{Coq Representation of Our Tool}
Our system contains the following three global variables:
\begin{itemize}
\item A list of symbolic execution trees $\in \tree$ called \textit{tree\_list} that represent the list of trees returned by the recursive strategy.
\item A concrete state $\in \concstates$ to represent the initial system state, called \textit{init\_concrete state}.
\item A set of concrete states $\in \concstates$ to represent all of the system error states, called \textit{error\_states}.
\end{itemize}

We then define the method $ \mathtt{execute\_tree\_list} : \{t\} \rightarrow \{\concstates\}$ , that takes a list of symbolic execution trees and executes them according to the inputs given by the leaves.

Additionally, we define the abstract method, $ \mathtt{get\_input} : \{\syminput\} \times \{\symalphabet\} \rightarrow \{\concstates\}$ which returns a concrete input that does not violate a given symbolic state's path constraint.
This method is bound by the requirement,

\begin{definition}[\emph{get\_input}]
$ \forall$ symbolic inputs $i' \in \syminputs$, tree nodes $n$, and $a = \mathtt{maptoalph}(\mathrm{alphabet})$
if $\exists$ a symbolic state $s \in \symstates$  such that
$n$ is a leaf of the tree output by $\symexecution(s, i)$ and 
$\mathtt{pc\_eval} (\mathtt{instantiate} (n.\pathcondition, a)) = \texttrue$, then
$\mathtt{instantiate}(i, a) = \mathtt{get\_input}(i)$.
\end{definition}

\subsubsection{Instantiation Operations}

Our two instantiation operations are defined in the following way: 
$$\mathtt{concretize\_root} : \{ \tree \} \rightarrow \{\concstates\}$$

$$\mathtt{concretize\_leaf} : \{ \tree \} \rightarrow \{\concstates\}$$

They are bound by the following requirements:

\begin{definition}[\emph{concretize\_root}]
$\forall$ symbolic execution trees $t$,  concrete states $cs$,
$cs \in$ circle\_op\_1($t$) $\leftrightarrow$ 
$\exists$ a symbolic state $s$, a tree node $s'$, and $a = \mathtt{maptoalph}(\mathrm{alphabet})$ such that
$s$ is the root of $t$, $s'$ is the selected leaf of $t$, 
$\mathtt{pc\_eval} (\mathtt{instantiate} (s'.\pathcondition, a)) = \texttrue$, and 
$cs = \mathtt{instantiate}(s, a)$.
\end{definition}

\begin{definition}[\emph{concretize\_leaf}]
$\forall$ symbolic execution trees $t$,  concrete states $cs$,
$cs \in$ circle\_op\_2($t$) $\leftrightarrow$ 
$\exists$ a symbolic state $s$, a tree node $s'$, and $a = \mathtt{maptoalph}(\mathrm{alphabet})$ such that
$s$ is the root of $t$, $s'$ is the selected leaf of $t$, 
$\mathtt{pc\_eval} (\mathtt{instantiate} (s'.\pathcondition, a)) = \texttrue$, and 
$cs = \mathtt{instantiate}(s', a)$.
\end{definition}


We now can formally prove the following lemma, which we will use in our proof:
\begin{lemma} \label{cop}
forall symbolic states $s$, symbolic inputs $i'$, concrete states $c$, and $a = \mathtt{maptoalph}(\mathrm{alphabet})$,
if $cs \in \mathtt{concretize\_root}(t)$,
then 
$conc\_ex(cs, \mathtt{get\_input} ($i'$)) \in \mathtt{concretize\_leaf}(t)$,
where $l$ is a leaf of $t$ and $t = $ \symexecution($s, i'$).
\end{lemma}

In order to prove this, we utilize the commutativity property expressed earlier.


\subsubsection{Recursive Strategy Requirements}
We formally express the requirements stated of the strategy by Zhang et al. \cite{zhang2018recursive}.
The following requirements, when placed on our system, should be enough to prove that the strategy works as expected:

\setcounter{property}{0}
\renewcommand{\theproperty}{Z.\arabic{property}}
\begin{property}[Start in initial state]
  \label{prop:startinit}
$init\_concrete state \in \mathtt{concretize\_root}(first\_elem (tree\_list))$.
\end{property}

\begin{property}[End in error state]
  \label{prop:enderror}
$ \mathtt{concretize\_leaf} (last\_elem (tree\_list)) \cap error\_states 
\neq empty\_set $.
\end{property}

\begin{property}[Stitch trees together]
  \label{prop:stitch}
for all symbolic execution trees $a$ $b$, 
if $a$ and $b$ are consecutive in $tree\_list$, then 
$\mathtt{concretize\_leaf} (a) \subseteq
\mathtt{concretize\_root}(b) $.
\end{property}

These properties end up not being sufficient for proving the tool works. 
We make Property 2 stronger by replacing it with the following property:

\setcounter{property}{1}
\renewcommand{\theproperty}{Z.\arabic{property}'}
\begin{property}[Property~\ref{prop:enderror} correction]
  \label{prop:correctedz2}
$\mathtt{concretize\_leaf} (last\_elem (tree\_list))
\subseteq error\_states $.
\end{property}



Our main correctness theorem that we prove is Theorem \ref{thm:sufficiency}. In other words, given our three property requirements, executing our tree\_list will get us to an error state.
