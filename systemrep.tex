\subsection{Coq Representation of Our Tool}
Our system contains the following three global variables:
\begin{itemize}
\item A list of SE\_trees called \textit{tree\_list} that represent the list of trees returned by our tool.
\item A list of conc\_states to represent the initial system state, or \textit{init\_conc\_state}.
\item A set of conc\_state lists to represent all of the system error states, or \textit{Error\_States}.
\end{itemize}

We then define the method \textit{execute\_tree\_list}, that takes a list of SE\_trees and executes them according to the inputs given by the leaves.

Additionally, we define the abstract method, \textit{get\_input} which returns a list of inputs that do not violate a given sym\_state's pc.
This method is bound by the requirement,
\begin{axiom}
forall SE\_trees $t$, input lists $li$, and conc\_state lists $lcs$,  
if $li = get\_input (get\_pc (l)) $, where $l$ is a leaf of $t$,
then there exists a sym\_state $s'$ such that
 $pc\_eval (get\_pc (s'), lcs, li) = True$.
\end{axiom}

\subsubsection{Circle Operations}
The recursive symbolic execution tool utilizes two circle operations. 
They define them in the following way: 

``Let $\mathcal{E}$ represent the symbolic exploration of one clock cycle of a processor modeled by $M$. Let $n_r = (s_r,\pi_r)$ be the root node of tree $\mathcal{E}$ and let $n_l = (s_l,\pi_l)$ be a leaf node of the same tree. 
Then $s_r \circ \pi_l$ represents the set of concrete states, and $s_l \circ \pi_l$ represents the set of concrete next-states, that are at the end-points of the path from $n_r$ to $n_l$.'' (citation)

For our proof we let $circle\_op\_1 =  s_r \circ \pi_l$ and $circle\_op\_2 =  s_l \circ \pi_l$.
Both operations take the whole SE\_tree as input.

We now can formally prove the following lemma, which we will use in our proof:
\begin{lemma} \label{cop}
forall SE\_trees $t$ and conc\_state lists $csl$,
if $csl \in circle\_op\_1(t)$,
then 
$conc\_ex(csl, get\_input (get\_pc (l))) \in circle\_op\_2(t)$,
where $l$ is a leaf of $t$.
\end{lemma}

In order to prove this, we utilize the commutativity property expressed earlier.


\subsubsection{Tool Requirements}
We formally express the requirements stated of the tool by Zhang et al. (citation).
The following requirements, when placed on our system, should be enough to prove that the tool works as expected:
\textbf{Axiom (Property $1$):} 
$init\_conc\_state \in circle\_op\_1 (first\_elem (tree\_list))$.

\textbf{Axiom (Property $2$):}
$ circle\_op\_2 (last\_elem (tree\_list)) \cap Error_States 
\neq empty\_set $.

\textbf{Axiom (Property $3$) :} 
for all SE\_trees $a$ $b$, 
if $a$ and $b$ are consecutive in $tree\_list$, then 
$circle\_op\_2 (a) \subseteq
circle\_op\_1 (b) $.

These properties end up not being sufficient for proving the tool works. 
We make Property 2 stronger by replacing it with the following property:

\textbf{Axiom (Property $2'$):}
$circle\_op\_2 (last\_elem (tree\_list))
\subseteq Error\_States $.



Our main sufficiency theorem that we prove is the following:
\begin{theorem}
$execute\_tree\_list (tree\_list) \in Error\_States$.
\end{theorem}
 In other words, given our three property requirements, executing our tree\_list will get us to an error state.