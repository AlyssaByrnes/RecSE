\section{Introduction}
\cks{15 pages, excl. bib, excl. appdx}

Researchers have recently begun exploring the use of software-style symbolic execution for the
verification of hardware designs~\cite{mukherjee2015hardware,liu2009star}. Symbolic execution has a proven track record in the software community as a
bug-finding tool~\cite{?} and as an aid in formal
verification~\cite{?}. However, bringing these benefits to bear on hardware
designs has been a challenge---the complexity of the search space of relatively
simple designs more closely resembles that of large, continuously interactive
software systems than that of the stand-alone software programs that are the classic
targets of symbolic execution. In response to this challenge a recent paper proposed a recursive
search strategy for symbolic execution~\cite{zhang2018recursive}. Zhang et
al.~showed the strategy to be
practical~\cite{zhang2018end}, but the soundness of the approach has not been
demonstrated. A proof of correctness is needed.

In this paper we prove that a recursive search strategy for the
symbolic execution of hardware designs is sound: a list of
constraints returned by a successful search defines a set of concrete input
sequences, each of which will take the processor from its initial reset state to
an error state.

Our goal is to validate the search strategy itself rather than any one implementation
of it. Therefore we decouple our model of symbolic execution from the particular
programming language to be symbolically executed. We formalize an abstract model of symbolic
execution in Gallina, the specification language of the Coq proof
assistant~\cite{?}; the structure of the model is built
around the three fundamental properties of symbolic execution as first laid out
by King in 1976~\cite{}. This has the advantage of providing soundness
guarantees for the recursive search strategy when implemented by any symbolic
execution engine which abides by the three King properties.

\cks{In here give high level overview of the proof approach: SE represented as
  trees; proof by induction over list of trees.}

We find that the search strategy as originally proposed is not sound---that is, the
search may find a symbolic path for which no concrete path from the processor's initial state
to the given error state exists. We tighten one of the three
requirements of the strategy and make explicit an unstated assumption of the
original paper. We then prove the modified strategy is sound.

We present two contributions of this work:
\begin{itemize}
  \item An abstract model of symbolic execution expressed in the Coq
    framework. Those wishing to verify a particular symbolic execution engine
    can use our abstract model as a starting point, iteratively refining it to
    build a provably correct implementation. We make our model available online.
\item We verify the soundness of the recursive search strategy for symbolic
  execution. We find and fix a flaw in the original formulation of the
  strategy. Although the recursive search strategy was originally developed for
  the verification of hardware designs, any symbolic execution engine that
  implements the proven strategy will be assured the same guarantee of soundness.
\end{itemize}
