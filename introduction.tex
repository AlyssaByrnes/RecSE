\section{Introduction}
\cks{15 pages, excl. bib, excl. appdx}

Researchers have recently begun exploring the use of software-style symbolic execution for the
verification of hardware designs~\cite{mukherjee2015hardware,liu2009star}. Symbolic execution has a proven track record in the software community as a
bug-finding tool~\cite{?} and as an aid in formal verification~\cite{?}. However,
handling the complexity and search space of hardware designs has been a
challenge. In response to this challenge a recent paper proposed a recursive
search strategy~\cite{zhang2018recursive}. The strategy has been shown to be
practical~\cite{zhang2018end}, but the soundness of the approach has not been
demonstrated. A proof of correctness is needed.


In this paper we prove the validity of the recursive search strategy for the
symbolic execution of hardware designs. We formalize a model of symbolic
execution and prove that a recursive search strategy is sound: A list of
constraints returned by a successful search defines a set of concrete input
sequences, each of which will take the processor from its initial reset state to
an error state.

Our goal is to validate the search strategy itself rather than any one implementation
of it. Therefore we decouple our model of symbolic execution from a particular
coding language to be symbolically executed. The structure of the model is built
around the three fundamental properties of symbolic execution as first laid out
by King in 1976~\cite{}.

Our insight is that by building a model of symbolic execution based purely on
the three fund...~\cite{}, we can decouple the proof of the validity of the
search strategy from a proof about the correctness of any one particular
symbolic execution engine. Any symbolic exploration that uses the search
strategy we study here will produce sound results \cks{this is too strong}.
We find that the search strategy as originally proposed is not sound---that is, the
search may find a symbolic path for which no concrete path from the processor's initial state
to the given error state exists. We tighten the requirements of two of the three
requirements of the strategy and then prove the modified strategy correct.

We take advantage of the fact that/
Our insight is that both the recursive search strategy and symbolic execution
have clearly defined properties that are sufficient or assumed sufficient to
make the approach work.  make the a proof of soundness of the search strategy depends on a 

We use XXX, Coq's modeling language to build an abstract model of symbolic execution that 


